---
title: "Simple Composition with Array.Reduce"
date: 2020-01-16
tags:
  - Javascript
---

While looking at [functional-php](https://github.com/lstrojny/functional-php), I saw a pretty neat way of doing composition with an array_reduce method, and wanted to recreate it in JavaScript. There are plenty of libraries that implement this, but it's pretty fun knowing that you can get this functionality with a couple lines of plain JavaScript.

Here it is:

```js
const compose = (...funcs) =>
  funcs.reduce((previous, current) => x => current(previous(x)));
```

First, the spread operator here has the effect of accepting all the arguments as a single array, giving us access to the powerful array methods. We won't have to pass an array of functions, and can just pass an arbitrary number of parameters:

```js
const compose = (...funcs) => {
  // ...
};

const timesTwo = x => x * 2;
const timesThree = x => x * 3;

const timesTwelve = compose(timesTwo, timesTwo, timesThree);
```

The compose function must itself return a function, so we know that we'll need to reduce this array of functions into a single function. Calling reduce on the arguments array (funcs) will involve calling each function with some value x, 

```js
funcs.reduce(
  (previous, current) => x => current(previous(x))
);
```
Note: for composition to work, the composed functions must be *endomorphic*, meaning that the input and outputs of the function must be the same.

What I'm still unsure about is that, in the functional-php implementation, they passed an identity function as the initialValue for the reduce function. I thought this was necessary to make it work, but after removing it compose works just fine.

```js
const compose = (...funcs) =>
  funcs.reduce(
    (previous, current) => x => current(previous(x)),
    x => x
  );
```

And if you prefer to have functions evaluated from right to left, you can use reduceRight instead:

```js
const compose = (...funcs) =>
  funcs.reduceRight((previous, current) => x => current(previous(x)));
```
